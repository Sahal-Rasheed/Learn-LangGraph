# LangGraph
LangGraph is very low-level, and focused entirely on agent orchestration. LangGraph is focused on the underlying capabilities important for agent orchestration: durable execution, streaming, human-in-the-loop, and more.

Note: If wanted a higher-level abstraction, then use LangChain’s agents that provide pre-built architectures for common LLM and tool-calling loops.

## ELEMENTS
Elements in LangGraph

### 1. State
> **State** is a shared data structure that holds the current information or context of the entire application. Its like application m/y, keeping track of variables and data that nodes can access and modify as they execute

### 2. Nodes
> **Nodes** are individual functions or o/p that perform specific tasks within the graph. Each node receives input (often the current state), processes it, and produces an output or an updated state. 

### 3. Graph
> **Graph** in LangGraph is the overarching structure that maps out how different tasks (nodes) are connected and executed. It visually represents the workflow, showing the sequence and conditional paths b/w various operations. Eg:- A road map displaying the different routes connecting cities, with intersections offering choices on which path to take next.

### 4. Edges
> **Edges** are the connections b/w nodes that determine the flow of execution. They tell us which node should be executed next after the current one completes its task. Edges can also represent conditional paths, allowing for branching logic based on the state or output of previous nodes.

### 5. Conditional Edges
> **Conditional Edges** are specialized connections that decide the next node to execute based on specific conditions or logic applied to the current state or output of a node. They enable branching in the workflow, allowing for different execution paths depending on the results of previous operations.

### 6. Start Node
> **Start Node** is the initial entry point of the graph where execution begins. It is a virtual entry point in LangGraph, marking where the workflow begins. It does not perform any operations itself but serves as the starting point for the graph's execution flow.

### 7. End Node
> **End Node** is the terminal point of the graph where execution concludes. It signifies the completion of the workflow in LangGraph. Similar to the Start Node, it is a virtual node that signifies the end of the workflow.

### 8. Tools
> **Tools** are external functions or services that nodes can call upon to perform specific tasks such as fetching data from an API etc. They enhance the capabilities of nodes by providing additional functionalities. Nodes are part of the graph structure, while tools are functionalities that nodes can utilize during execution.

### 9. ToolNode
> **ToolNode** is just a specialized type of node whose main job is to run a tool. It connects the tool's output back into the graph's state, so other nodes can use the results or information generated by the tool. 

### 10. StateGraph
> **StateGraph** is a class in LangGraph used to build and compile the graph structure. It manages the nodes, edges, and overall state, ensuring that the workflow operates in a unified way and that data flows correctly b/w different parts of the graph during execution. Its like a blueprint for the entire workflow, detailing how each component interacts and functions together.

### 11. Runnable
> **Runnable** in LangGraph is a standardized, executable component that performs a specific task within an AI workflow. It serves as a fundamental building block, allowing for us to create modular systems. ***Runnable*** can represent various operations whereas a ***Node*** in LangGraph typically receives a state, performs an action on them and then updates the state accordingly.

## MESSAGES
Messages in LangGraph/LangChain

### 1. Human Message
> **Human Message** represents input or communication from a human user.

### 2. AI Message
> **AI Message** represents output or response generated by AI models.

### 3. System Message
> **System Message** provides context or instructions to the AI model, guiding its behavior or responses.

### 4. Function Message
> **Function Message** represents a message returned by the LLM when it decides that a tool/function should be called. A Function Message is created by the LLM when it decides that a tool (function) should be executed. It contains which tool to call and the arguments for that tool. In simple terms: “LLM requesting a tool call.”

### 5. Tool Message
> **Tool Message** represents the response from your tool/function after it runs. Similar to Function Message, but specific to tool. A Tool Message is created by your tool/function as the response to the LLM’s request. In simple terms: “Result returned from the tool to the LLM.” 